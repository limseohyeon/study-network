# HTTP

---

- 서버
    - 리소스를 제공한다.
    - Response를 송신 한다.
- 클라이언트
    - 리소스를 요청하는 역할
    - Request를 송신한다

클라이언트가 Request를 요청하지 않으면 서버는 Repsonse를 반환 하지 않는다.

## Request

---

```java
GET/index.html HTTP /1.1
Host: www.hacker.jp
```

- 메소드(GET) : 서버에 요구하는 종류
- 리퀘스트 URI(index.html) : 요구 대상인 리소스
- HHTP 버전 번호(HTTP/1.1)  : 클라이언트 식별

## Response

---

```java
HTTP /1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type text/html

<html>
...
```

- HTTP 버전 : HTTP /1.1
- 처리 결과 : 200OK
- 헤더필드 : 리스폰스가 발생한 일시
- body : 빈 줄 이하, 소스 본체

## Statless

---

HTTP는 상태를 유지하지 않는 스테이트리스(Statless) 프로토콜이다. 즉, 전송한 request, response에 대해서는 전혀 기억하지 않는다.

Stateless 장점

- 범위성(scalability)확보 : 많은 데이터를 빠르고 확실하게 처리한다.

## Request URI

---

HTTP는 URI를 사용해 인터넷 상의 리소스를 지정한다.

URI를 지정하는 방법에는 여러 종류가 있다.

- 모든 URI를 리퀘스트 URI에 포함한다.
- Host 헤더 필드에 네트워크 로케이션을포함한다.
- 서버 자신에게 리퀘스트를 송신하는 경우 URI에 [*]를 지정할 수 있다

## Request Method

---

메소드는 리소스에 어떤 행동을 원하는지 지시하기 위해 사용한다.

### GET : 리소스 휙득

URI 로 식별된 리소스를 가져올 수 있도록 한다.

### POST : 엔티티 전송

엔티티를 전송하기 위해 사용한다. GET도 가능하나, 보통 POST를 사용한다.

### PUT : 파일 전송

파일을 전송하기 위해 사용한다.

HTTP/1.1 PUT 자체에는 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되지 않는다. 이를 위해 인증 기능, REST와 같이 웹끼리 연계하는 설계 양식을 사용한다.

### HEAD:메시지 헤더 취득

GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다.

URI 유효성, 리소스 갱신 시간을 확인하는 목적으로 사용한다.

### DELETE : 파일 삭제

파일을 삭제하기 위해 사용한다.

PUT과 마찬가지로 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되지 않는다. 이를 위해 인증 기능, REST와 같이 웹끼리 연계하는 설계 양식을 사용한다.

### OPTIONS : 제공하고 있는 메소드 문의

URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용한다.

### TRACE : 경로 조사

WEb서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킨다.

- Max-Forwards 라는 필드를 헤더 필드에 추가한다.
- 서버를 통과하면 수치를 감소 시킨다.
- 수치가 0이 된 서버에서 상태코드 200OK를 리스폰스 한다.

리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 조사할 수 있다. 프록시 등을 중계해 오리진 서버에 접속할 때 그 동작을 확인위해 사용하나, 크로스 사이트 트레이싱(XST) 과같은 공격 등 보안 문제가 있기 때문에 거의 사용하지 않는다.

### CONNECT : 프록시에 터널링 요구

프록시에 터널 접속 확립을 요해 TCP 통신을 터널링 시키기 위해 사용한다. 주로 SSL, TLS 등의 프로토콜로 암호화 된 것에 사용한다.

- 터널링 : 데이터 패킷을 특정 사용자끼리만 유효한 패킷으로 변환해 논리적인 터널을 만드는 것을 의미함.

## 지속 연결

---

기존 HTTP는 TCP에 의해 연결과 종료가 반복 되었다. 그러나 다량의 이미지를 포함한 문서가 늘어나며 지속 연결이라는 방법이 고안 되었다.

지속 연결은 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지해 파이프라인화를 가능하게 한다.

**지속 연결 장점**

- TCP 커넥션 연결-종료 반복 오버헤드 감소로 서버 부하 경함
- HTTP 리퀘스트-리스폰스 빠르게 완료

**파이프라인화**

리스폰스를 기다리지 않고 바로 다름 리퀘스트를 보낼 수 있도록 한다.

## 쿠키

---

HTTP의 Stateless 때문에 과거 교환한 데이터 상태를 관리하지 않는다. Stateless 성의 문제를 보완하고자 나온 것이 쿠키이다. 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해 클라이언트 상태를 파악하기 위한 시스템이다.

**쿠키를 가지지 않은 상태에서의 리퀘스트**

- 클라이언트 : 리퀘스트 송신
- 서버 : 리스폰스 + 쿠키 송신

**쿠리를 가지고 있는 상태에서의 리퀘스트**

- 클라이언트 : 리퀘스트 + 쿠키 송신
- 서버 : 리스폰스
